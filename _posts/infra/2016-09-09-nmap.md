---
layout: post
title:  "[CentOS] CentOS6 NMAP(Network MAPper)"
date:   2016-09-09 19:41:26
author: Choi HyeSun
categories: infra
tags:
  - CentOS
  - NMAP
  - NMAP 사용법
---

## NMAP(Network MAPper)이란?

- 시스템에 열려있는 TCP나 UDP 포트를 검색하는 프로그램

- 시스템 관리자가 네트워크를 통해 서비스를 구동하는 서버에 자가 테스트를 시행하여 외부와 연결되는 포트가 어떤 것이 열려있는지, 각 포트는 어떤 프로그램이 사용하는지 확인하는 프로그램

- 원격지 또는 로컬 호스트의 열려진 포트를 검색하는 프로그램

<br>
<br>

## NMAP의 특징

- SYS scan, FIN scan, Xmas scan, Null scan 등 다양한 스캔 방법 제공

- 방대한 네트워크 스캐닝 시 살아있는 호스트 목록을 만들어 모두 스캔할 수 있도록 지원

- TCP/IP Stack fingerprinting 기법을 이용해 시스템의 운영체제를 검색

- TCP Sequence Number 추측 기능을 지원해 IP Spoofing 공격 가능성을 평가

- ident 정보를 얻는 기능 지원

- 스캐닝 결과를 로그 파일로 기록

- GUI 환경 지원

- GPL 라이선스로 자유롭게 사용 가능
  
<br>
<br>

## NMAP 프로그램 다운 및 설치

- 다운로드

  - NMAP 프로그램은 http://www.insecure.org/nmap에서 다운로드 받을 수 있음
  
  - 소스 프로그램과 RPM 패키지 프로그램 두 가지 모두 제공하고 있으니 원하는 형식의 프로그램을 다운받은 후 설치
  
- yum으로 설치

{% highlight java %}
yum install -y nmap
{% endhighlight %}

## NMAP 사용 형식

- nmap \[스캔타입] \[옵션] \<스캔대상 서버\[도메인 혹은 IP 주소]>

- 스캔 타입

  - \-sT : connect() 함수를 이용한 Open 스캔

  - \-sS : 세션을 성립시키지 않는 SYN 스캔

  - \-sF : FIN 패킷을 이용한 스캔

  - \-sN : NULL 패킷을 이용한 스캔

  - \-sX : XMAS 패킷을 이용한 스캔

  - \-sP : ping을 이용한 호스트 활성화 여부 확인

  - \-sU : UDP 포트 스캔

  - \-sR : RPC 포트 스캔

  - \-sA : ACK 패킷에 대한 TTL 값의 분석

  - \-sW : ACK 패킷에 대한 윈도우 크기 분석

  - \-b : FTP 바운스 스캔

- 옵션

  - \-f : 스캔할 때 방화벽을 통과할 수 있도록 패킷을 조각냄

  - \-v : 스캔의 세부사항 표시

  - \-P0 : 스캔 전 ping을 하지 않음(ICMP Echo Request를 허용하지 않는 호스트에 대한 스캔을 할 때 설정)

  - \-PT : Ping의 대용으로 ICMP 패킷을 이용하지 않고, TCP 패킷을 이용하여 해당 시스템이 작동 중인지 검사

  - \-PS : TCP의 SYN 패킷만을 보내 시스템의 활성화 여부 검사

  - \-PI : 시스템의 활성화 여부를 ICMP로 검사

  - \-PB : TCP와 ICMP 둘 다 사용해서 호스트들의 활성화 여부 검사

  - \-O : 시스템의 운영체제 추정

  - \-I : Identification 프로토콜(RFC 1413)을 사용해 열려있는 프로세스가 어떤 사용자에 의한 것인지 검사

  - \-n : DNS 룩업(lookup)을 하지 않음

  - \-R : DNS 룩업(lookup)을 함

  - \-P : 특정 포트 스캔 (ex> nmap –sF –P 21,23 172.16.0.3)

- 시간 차 옵션

  - \-T 0 : Paranoid (ex> nmap –sS –T 0 172.16.0.4)

  - \-T 1 : Sneaky

  - \-T 2 : Polite

  - \-T 3 : Normal

  - \-T 4 : Aggressive

  - \-T 5 : insane

- 예제

  - 열린 포트 확인 : nmap localhost
  
  ![image](/img/2016-09-09/nmap-001-test1.png)
  
<br>
<br>

## 스캔이란?

- 서비스를 제공하는 서버의 작동 여부와, 그 서버가 제공하고 있는 서비스를 확인하기 위한 것

- TCP 기반의 프로토콜은 기본적으로 질의(request)를 보내면 응답(response)을 하기 때문에, 이것을 이용하여 확인하는 것

<br>

#### ICMP(Internet control Messaging Protocol) 스캔

##### 방법 1. ping을 사용한 Echo Request(Type 8), Echo Reply(Type 0)을 이용하는 방법

- ping은 ICMP 프로토콜을 사용하여, 네트워크와 시스템이 정상적으로 작동하는지 확인하기 위한 간단한 유틸리티

{% highlight bash %}
[root@localhost ~]$ ping localhost
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.020 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.030 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.028 ms
64 bytes from localhost (127.0.0.1): icmp_seq=4 ttl=64 time=0.028 ms
64 bytes from localhost (127.0.0.1): icmp_seq=5 ttl=64 time=0.027 ms
{% endhighlight %}

- PING localhost (127.0.0.1) **56**(84) bytes of data.

  - 보내는 ICMP Echo Request 패킷의 크기
  
  - 운영체제마다 보내는 바이트 길이가 다름(윈도우 32byte, 리눅스/유닉스 : 56byte)
  
- **64 bytes** from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.020 ms

  - 공격 대상에서 보내온 ICMP Echo Reply 패킷의 크기

  - 공격자가 보낸 패킷과 같은 크기의 패킷
  
- 64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 **time=0.020 ms**

  - Echo Request 패킷이 보내진 뒤 Replay 패킷을 받기까지의 시간
  
- 64 bytes from localhost (127.0.0.1): icmp_seq=1 **ttl=64** time=0.020 ms

  - TTL(Time To Live) 값으로 운영체제에 따라 Default TTL 값이 다름

  - TTL : 라우터 하나를 지날 때 마다 1씩 줄어들며, 0이 되면 패킷을 폐지

  - 줄어든 TTL 값으로 원격지의 시스템이 몇 개의 라우터를 거쳐서 도달할 수 있는지 알 수 있고 어떤 운영체제인지 어느 정도 판별 가능

![image](/img/2016-09-09/nmap-002-packet1.png)

- 윈도우는 ping을 보내면 기본적으로 4개의 ICMP 패킷을 보내지만, 리눅스는 중지 명령을 내리기 전까지 Request 패킷을 계속 보냄

- 리눅스 ping의 패킷은 구성은 조금 다르나, 기본은 윈도우와 같음

<br>

##### 방법 2.	Timestamp Request(Type 13), Timestamp Reply(Type 14)를 이용한 방법

- Timestamp request는 원격지 시스템의 현재 시간을 알아보기 위한 패킷

- 하지만 Timestamp request 패킷에 Reply 패킷을 돌려보내는 시스템이 시간만을 알려준다고 생각할 수는 없음
<br>(상대 시스템의 Reply 패킷이 돌아온다는 것은 상대 시스템이 활성화 되어 있다는 뜻)

<br>

##### 방법 3. Information Request(Type 15), Information Reply(Type 16)을 이용한 방법

- 이 패킷은 메인 프레임의 터미널과 같이 부팅할 때 자신의 디스크가 없는 시스템에 스스로 자신의 IP를 설정할 수 있도록 하는 패킷

- 이 방법 역시 Timestamp 패킷과 마찬가지로 죽어있는 시스템은 Reply 패킷을 보내오지 않을 것

<br>

##### 방법 4. ICMP Address Mask Request(Type 17), ICMP Address Mask Reply(Type 0)를 이용한 방법

- 이 패킷은 Information Request패킷과 같이 터미널이 부팅될 때 자신이 속해있는 네트워크의 서브넷마스크를 알기 위해서 보내는 패킷

- 앞의 두 가지 방법과 마찬가지로 Reply 패킷을 돌려보내는지 확인함으로써 상대 시스템의 활성화 여부를 확인

<br>

##### 방법 2, 3, 4는 모든 운영체제에서 작동하지 않음

- 운영체제에 따라서 세가지 중 일부만 지원하며, 지원 여부에 따라 운영체제를 짐작할 수 있다

![image](/img/2016-09-09/nmap-003-os1.png)

- sing 툴을 사용하면 2, 3, 4번 스캔을 할 수 있다.

{% highlight text %}
EXAM>
Timestamp 패킷
./sing –c 1 –tstamp 172.16.0.2
Information 패킷
./sing –info 172.16.0.2
Address Mask 패킷
./sing –mask 172.16.0.2
{% endhighlight %}

<br>
<br>

#### 스위핑(sweeping)

- ICMP를 이용한 여러 가지 ping은 하나의 시스템을 조사하기에는 적절하나 큰 네트워크에서 활성화 시스템을 찾는 데는 그다지 효과적이지 않음

- 스위핑은 네트워크 전체에서 활성화 시스템을 찾는 것

- 스위핑은 검색하고자 하는 네트워크에 브로드캐스트 ping을 보내거나 자동화 도구를 이용해 특정 범위의 네트워크에 ping을 보냄

##### fping을 이용한 스위핑 (sweeping) 예

![image](/img/2016-09-09/.png)

<br>
<br>

## TCP 헤더의 플래그 비트

- TCP 헤더에는 플래그 비트가 6개 정의되어 있음

- 필드 값이 1이면 각 플래그에 해당하는 의미를 가짐

<br> 

1. URG

  - Urgent Pointer 필드가 유효한지를 나타냄
  
  - 긴급 데이터를 전송하기 위해 사용
  
2. ACK

  - Acknowledgment Number 필드가 유효한지를 나타냄

  - 정상적인 피기배킹 방식의 양방향 통신 환경에서, 양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트가 1로 지정된다고 생각할 수 있음

3. PSH 

  - 현재 세그먼트에 포함된 데이터를 상위 계층에 즉시 전달하도록 지시할 때 사용
  
  - 수신자에게서 PSH 세그먼트에 대한 응답 프레임이 도착하면, 프레임의 Acknowledgement Number 필드에 표시한 숫자까지의 모든 데이터가 상대 프로세스의 상위 계층에 전달되었음을 의미
  
4. RST

  - 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용으로 사용
  
  - 송신자가 전송을 마쳤으나 수신자에게 아직 도착하지 못한 세그먼트, 혹은 수신자가 아직 긍정 응답하지 않은 세그먼트는 연결이 재설정되었을 때 반드시 재전송되어야 함
  
5. SYN 

  - 연결 설정 요구를 의미하는 플래그 비트므로 가상 회선 연결을 설정하는 과정에서 사용

6. FIN

  - 한쪽 프로세서에서 더는 전송할 데이터가 없어 연결을 종료하고 싶다는 의사 표시를 상대방에게 알리는 데 사용
  
  - 현재 전송 과정에 있는 데이터는 계속 처리할 수 있으며, 상대편 프로세스의 데이터 전송에 장애가 발생하지 않음
  
  - 연결 해제는 양쪽 프로세스 모두가 FIN 플래그를 전송해야 완료
