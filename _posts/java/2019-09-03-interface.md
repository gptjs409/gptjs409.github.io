---
layout: post
title:  "[Java] 인터페이스(interface)"
date:   2019-09-03 19:51:33
author: Choi HyeSun
categories: java
tags:
  - Java
  - 인터페이스
  - interface
  - default method
  - static method
  - java 상속
  - java 다중상속
  - 구현
---

## 인터페이스(interface) - 정의

- 일종의 추상클래스

- 추상클래스처럼 추상메서드를 갖지만, 추상클래스보다 추상화정도가 높음

  - 인터페이스 : 기본 설계도

  - 추상클래스 : 미완성 설계도

- 다른 클래스를 작성하는데 도움을 줄 목적으로 작성

<br>
<br>

## 인터페이스 - 작성

- 클래스 작성과 동일하지만 class → interface로 바꾸어 작성

  - interface 인터페이스 이름 { 내용 }

  - 인터페이스 명은 보통 'able'로 끝나는 경우가 많음 > 강제는 아님<br>able : ~을 할 수 있는

- 인터페이스 멤버 제약 사항

  - 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있음

  - 모든 메서드는 public abstract이어야하며, 이를 생략할 수 있음
  
  - 단) static 메서드와 default 메서드는 예외로 함(JDK 1.8 ~)
  
- 제어자는 동일하기 때문에 편의상 생략하며, 컴파일시 컴파일러가 자동으로 추가

<br>
<br>

## 인터페이스 - 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있음

- 클래스와 다르게 다중 상속이 가능함 (extends Interface1, Interface2)

- 클래스와 동일하게 부모인터페이스의 부모인터페이스도 상속함

  - 단, Object처럼 시조(조상) 인터페이스는 존재하지 않음

<br>
<br>

## 인터페이스 구현

- 그 자체로는 인스턴스를 생성할 수 없음(추상메서드와 동일)

- 클래스는 인터페이스의 성질을 받을 때 구현이라 표현하며, implements를 사용함

  - 구현하는 인터페이스의 메서드(abstract 메서드) 중 일부만 구현한다면, 클래스는 abstract로 선언해야 함

- 상속과 동시에 할 수 있음

  - class 클래스명 extends 부모클래스 implements 구현할인터페이스1, ... { }

  - 상속 / 구현 순

- 구현시, interface로부터 받는 값에 대한 접근 제어자는 public

  - interface는 public이고, 오버라이딩할 때는 부모클래스의 메서드랑 같거나 넓은 범위의 접근 제어자를 지정해야하기 때문
  
<br>
<br>

## 인터페이스를 이용한 다중 상속

- 자바도 인터페이스를 이용하면 다중 상속이 가능하지만, 사용하는 경우가 거의 없음

  - 인터페이스는 다중상속을 위한 것이 아님
  
- 인터페이스가 다중상속이 가능한 이유 > 인터페이스는 static상수만 정의

  - 조상클래스의 멤버변수와 충돌하는 경우가 거의 없음

  - 충돌하더라도 클래스 이름을 붙여서 구분 가능

  - 추상메서드는 구현내용이 없기 때문에, 메서드명이 일치하는 경우 상속받으면 되기 때문에 문제 없음
  
- 인터페이스를 이용한 다중 상속

  - A와 B 클래스를 상속받아야 할 때,
  <br>A클래스 : 상속(extends) 받아서 사용
  <br>B클래스 : 구현한 인터페이스(Bi)를 구현 Implements, 인스턴스를 생성, 구현한 인터페이스(Bi)의 메서드에서 B 인스턴스의 메서드를 호출
  
<br>
<br>

## 인터페이스를 이용한 다형성

- 인터페이스를 구현한 클래스의 부모라고 볼 수도 있기 때문에, 해당 인터페이스 타입의 참조변수로 구현한 클래스의 인스턴스를 참조할 수 있음

  - 단, 동일하게 인터페이스에 정의된 멤버들만 호출 가능

- 인터페이스 타입으로 형변환도 가능함

- 매개변수의 타입으로 사용될 수 있음

  - 메서드 호출시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 함

- 리턴타입으로 인터페이스의 타입을 지정할 수 있음

  - 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환

<br>
<br>

## 인터페이스의 장점

- 개발시간을 단축시킬 수 있음

- 표준화가 가능함

- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음

- 독립적인 프로그래밍이 가능함

<br>
<br>

## 인터페이스의 이해

- 클래스를 사용하는 쪽(User)와 클래스를 제공하는 쪽(Provider)이 있음

- 메서드를 사용(호출)하는 쪽(User)은 사용하려는 메서드(Provider)의 선언부만 알면 됨 (내용은 몰라도 무관)

<br>
<br>

## 디폴트 메서드

- (JDK 1.8~) 인터페이스에 추가 가능

- 추상메서드의 기본적인 구현을 제공하는 메서드

  - 추상메서드가 아니기 때문에 구현하지 않아도 됨

- 메소드 구현부가 있어야 함(body)

  - 앞에 키워드 default로 명시해주어야 함

  - 접근제어자는 public, 생략 가능함
  <br>유의) 접근제어자 (default)가 아님을

- 문제와 해결법

  - 여러 인터페이스의 디폴트 메서드간의 충돌
  <br>: 구현한 클래스에서 디폴트 메서드를 오버라이딩 해버리기(싹 다 무시)

  - 디폴트 메서드와 부모 클래스의 메서드간의 충돌
  <br>: 부모 클래스의 메서드 상속, 디폴트 메서드 무시

<br>
<br>

## static 메서드

- (JDK 1.8~) 인터페이스에 추가 가능

  - 인스턴스와 무관하므로 인터페이스에 추가 가능했지만, 기존에는 추가되지 않았었음(JDK 1.8~ 가능)
  <br>그래서 나왔던게 Collection 인터페이스의 Collections 클래스

- 접근 제어자가 항상 public이며 생략할 수 있음
