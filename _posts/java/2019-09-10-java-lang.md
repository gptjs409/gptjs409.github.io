---
layout: post
title:  "[Java] java.lang패키지"
date:   2019-09-10 19:45:27
author: Choi HyeSun
categories: java
tags:
  - Java
  - lang
  - java.lang
  - Object
  - String
---

## java.lang 패키지

- 자바 프로그래밍에서 가장 기본이 되는 클래스들을 포함

  - import문 없이 사용할 수 있음

- 자주 사용되는 클래스

  - Object 클래스 / String 클래스 / StringBuffer & StringBuilder 클래스 / Math 클래스 / 래퍼(wrapper)클래스

<br>
<br>

## Object 클래스

- 모든 클래스의 최고 부모(조상/시조)클래스

- Object 클래스의 멤버들은 모든 클래스에서 바로 사용 가능

- 멤버변수는 없고 11개의 메서드만 가지고 있음

|Object 클래스의 메서드|설명|
|---|---|
|**protected** Object clone()|객체 자신의 복사본을 반환<br>→ 객체 자신의 복사본(참조변수의 경우는 주소)를 복사(얕은 복사)하기 때문에 완전한 복사를 위해서는 overriding해서 사용할 것(깊은 복사)<br>→ 사용하려면<br>→→ 복제할 클래스가 Cloneable 인터페이스를 구현해야 함<br>→→→ Cloneable 인터페이스를 구현해야만 복제를 허용한다는 의미<br>→→ 접근 제어자를 protected에서 public으로 변경<br>→→ 부모클래스의 clone()을 호출하는 try-catch문을 작성<br>공변반환타입(JDK 1.5 ~ : covariant return type)<br>→ 오버라이딩할 때 부모메서드의 반환타입을 자식클래스의 타입으로 변경 허용<br>→ 부모클래스의 반환타입이 아닌, 반환되는 자식클래스의 타입으로 반환할 수 있어서 번거로운 형 변환이 줄어듦|
|public boolean equals(Object obj)|객체 자신과 객체 obj가 같은 객체인지 알려줌<br>같으면 true, 다르면 false 반환<br>→ 두 개의 참조변수가 같은 객체를 참조하고 있는지 판단(주소값)<br>→→ 내용을 비교하고 싶다면 overriding해서 사용할 것|
|**protected** void finalize()|객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출<br>이 때 수행되어야 하는 코드가 있을 때 오버라이딩(거의 사용 안함)|
|public Class getClass()|객체 자신의 클래스 정보를 담고있는 Class 인스턴스를 반환|
|public int hashCode()|객체 자신의 해시코드를 반환<br>→ 해싱(hashing)기법에 사용되는 해시함수 구현<br>→→ 해싱 : 데이터관리기법, 다량의 데이터릉 저장하고 검색하는데 유용<br>→ Object클래스에 정의된 hashCode메서드는 객체의 구조값을 이용해 해시코드 생성 = 서로 다른 두 객체는 서로 다른 hashCode<br>→→ 내용을 비교하기 위해 equlas를 overriding할 때 적절히 같이 해줘야 함<br>→ String은 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 overriding되어있음(String 객체 hashCode로 비교시 같은 응답 나옴)<br>→→ System.identityHashCode(Object x)는 객체의 주솟값으로 해시코드를 생성 = 모든 객체에 항상 다른 해시코드를 반환할 것을 보장 (String 객체 둘 비교시 다른 응답 나옴)|
|public String toString()|객체 자신의 정보를 문자열로 반환<br>→ 기본 : Class명@hashCode<br>→ 일반적으로 인스턴스나 클래스에 대한 정보 또는 인스턴스 변수의 값을 문자열로 변환하여 반환하도록 overriding|
|public void notify()|객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨움|
|public void notifyAll()|객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움|
|public void wait()<br>public void wait(long timeout)<br>public void wait(long timeout, int nanos)|다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 함<br>time = 1/1000, nonos = 1/10^9|

<br>
<br>

## Object 클래스 - clone의 사용 예

{% highlight java %}
int[] arr = {1, 2, 3, 4, 5};

// clone을 이용한 복사
int[] arrCloneA = arr.clone();

// System.arraycopy()를 이용한 복사
int[] arrCloneB = new int[arr.length];              // 배열 생성
System.arraycopy(arr, 0, arrCloneB, 0, arr.length); // 배열 복사


/* clone을 이용한 복사 대상
 * array(배열)
 * java.util 패키지의 Vector, ArrayList, LinkedList, HashSet, TreeSet
 *                   , HashMap, TreeMap, Calendar, Data
 * Cloneable 인터페이스를 구현한 클래스
 */
ArrayList listA = new ArrayList();
              ...
ArrayList listB = (ArrayList)list.clone();
{% endhighlight %}

<br>
<br>

## Object 클래스 - class 객체

- 클래스의 모든 정보를 담고 있음

- 클래스 당 1개만 존재

- 클래스 파일이 클래스로더(ClassLoader)에 의해 메모리에 올라갈 떄 자동으로 생성됨

- 클래스로더(ClassLoader)

  - 실행 시에 필요한 클래스를 동적으로 메모리에 로드

  - 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인

  - 메모리에 존재하면 객체의 참조를 반환
  <br>메모리에 존재하지 않으면 클래스 패스(classpath)에 지정된 경로를 따라서 클래스 파일을 찾음

  - 클래스 파일을 찾으면 해당 클래스 파일을 읽어서 Class 객체로 변환
  <br>클래스 파일을 못찾으면 ClassNotFoundException 발생

  - 클래스 파일을 메모리에 로드하고 변환

- 파일 형태로 저장되어 있는 클래스를 읽어서 Class 클래스에 정의된 형식으로 변환하는 것

- 클래스 파일을 읽어서 사용하기 편한 형태로 저장해놓은 것

{% highlight java %}
/* Class 객체 얻기 */
Class cObj = new Sunny().getClass(); // 생성된 객체로부터 얻기
Class cObj = Sunny.class;            // 클래스 리터럴(.*class)로부터 얻기
Class cobj = Class.forName("Sunny"); // 클래스 일므으로 부터 얻기

/* 객체 생성하기 */
Sunny s = new Sunny();               // new 연산자를 이용해 객체 생성
Sunny s = Sunny.class.newInstance(); // Class 객체를 이용해 객체 생성
  //newInstance()는 InstantiationException 발생 가능하므로 예외처리 필요

// 추가 동적으로 객체 생성 및 메서드를 호출하는 방법 : 리플렉션API(reflection API) 검색
// Java API문서에서 Class 객체를 찾아보면 클래스의 정보를 얻을 수 있는 많은 수의 메서드가 있음
{% endhighlight %}

<br>
<br>

## String 클래스

- Java에서 제공하는 문자열을 위한 클래스

  - 문자열을 저장하고 이를 다루는데 필요한 메서드를 제공

- 변경 불가능한(immutable) 클래스

  - 앞에 final이 붙어있으므로 상속 불가

  - String클래스는 문자열을 저장하기 위해서 문자열 배열 변수(char[]) value를 인스턴스 변수로 정의

  - 인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 이 인스턴스 변수(value)에 문자형 배열(char[])로 저장

  - 한번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어올 수만 있고, 변경할 수는 없음

<br>
<br>

## String 클래스 - 문자형 결합

- 새로운 문자열이 담긴 String 인스턴스를 생성하는 것 → 결합 횟수를 줄이는 것이 좋음

- 문자열을 다루는 작업이 많이 필요하다면

  - String 사용시 새로운 인스턴스를 계속 생성하여 메모리공간을 차지

  - StringBuffer클래스를 사용하는 것이 좋음(문자열 변경 가능하기 때문)

<br>
<br>

## String 클래스 - 문자형 비교 방법 2가지

- 문자열 리터럴을 지정

- 이미 존재하는 리터럴을 재사용함

  - String strA = "abc"; // 문자열 리터럴 "abc"의 주소가 strA, strB에 저장됨
  <br>String strB = "abc"; // 같은 주소값 저장

  - strA.equals(strB) → true : 값 비교
  <br>strA==strB → true : 주소값 비교

- String 클래스의 생성자를 사용

  - new 연산자에 의해서 메모리 할당이 이루어짐 (늘 새로운 String 인스턴스)

  - String strA = new String("abc"); // 새로 String 인스턴스가 생성되기 때문에
  <br>String strB = new String("abc"); // 다른 주소값

  - strA.equals(strB) → true : 값 비교
  <br>strA==strB → false : 주소값 비교

<br>
<br>

## String 클래스 - 문자열 리터럴

- 자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장

  - 클래스파일에 소스파일에 포함된 모든 리터럴의 목록이 있음

  - 해당 클래스파일이 클래스 로더에 의해 메모리에 올라갈 때, 이 리터럴의 목록에 있는 리터럴들이 JVM내에 있는 상수 저장소(constant pool)에 저장

- 같은 내용의 문자열 리터럴은 한 번만 저장

  - 문자열 리터럴도 String 인스턴스이고, 한 번 생성하면 내용을 변경할 수 없으니 하나의 인스턴스를 공유하면 되기 때문

<br>
<br>

## String 클래스 - 빈 문자열(empty string)

- char형 배열도 길이가 0인 배열을 생성할 수 있고, 이 배열을 내부적으로 가지고 있음

  - (길이가 0인 배열은 존재할 수 있음 - C언어는 불가)

- String s = ""; 일 때, 참조변수 s가 참조하고 있는 String 인스턴스는 내부에 'new char[0]'같이 길이가 0인 char형 배열을 저장

  - char c = '';는 불가 → char는 반드시 한 개의 문자를 지정해야 함 > char c = ' ';

- String의 초기화

  - 보통 각 타입의 기본값으로 초기화함
  
  - String은 기본값인 null보다는 빈 문자열로, char는 기본값인 '\u000'대신 공백으로 초기화하는 것이 보통
  
<br>
<br>

## String 클래스 - 자주 쓰는 생성자와 메서드

|메서드 / 설명|예제|결과|
|---|---|---|
|**String(String s)**<br>: 문자열을 갖는 인스턴스 생성|String s = new String("Sunny");|s = "Sunny"|
|**String(char[] value)**<br>: 문자배열을 문자열로 생성|char[] c = {'S', 'u', 'n', 'n', 'y'};<br>String s = new String(c);|s = "Sunny"|
|**String(StringBuffer buf)**<br>: StringBuffer와 같은 문자열 생성|StringBuffer sb = new StringBuffer("Sunny");<br>String s = new String(sb);|s = "Sunny"|
|**char charAt(int index)**<br>: 문자열의 index번째 문자 출력|String s = "Sunny";<br>String n = "12345";<br>char c1 = s.charAt(1);<br>char<br>c2 = n.charAt(1);|c1 = 'u'<br>c2 = '2'|
|**int compareTo(String str)**<br>: 주어진 문자열과 사전기준 정렬 비교<br>-1 (이전) / 0 (동일) / 1 (이후)|int i1 = "aaa".compareTo("bbb");<br>int i2 = "bbb".compareTo("bbb");<br>int i3 = "ccc".compareTo("bbb");|i1 = -1<br>i2 = 0<br>i3 = 1|
|**String concat(String str)**<br>: 문자열을 덧붙임|String s1 = "Su";<br>String s2 = s.concat("nny");|s1 = Su<br>s2 = Sunny|
|**boolean contains(CharSequence s)**<br>: 지정된 문자열이 포함되었는지 검사<br>\* CharSequence<br>=> String이 구현하고 있는 Interface임(StringBuffer/StringBuilder 등도)|String s = "Sunny";<br>boolean b = s.contains("un");|b = true|
|**boolean endsWith(String suffix)**<br>: 주어진 문자열로 끝나는지 검사|String file = "Sunny.txt";<br>boolean b = file.endWith("txt");|b = true|
|**boolean equals(Object obj)**<br>: 주어진 문자열 값을 비교<br>값이 다르면 false<br>주어진게 문자열이 아니면 false|String s = "Sunny";<br>boolean b1 = s.equals("Sunny");<br>boolean b2 = s.equals("sunny");<br>boolean b3 = s.equals(123);|b1 = true<br>b2 = false<br>b3 = false|
|**boolean equalsIgnoreCase(String str)**<br>: 주어진 문자열과 대소문자 구분없이 값을 비교|String s = "Sunny";<br>boolean b1 = s.equals("Sunny");<br>boolean b2 = s.equals("suNny");|b1 = true<br>b2 = true|
|**int indexOf(int ch)**<br>: 주어진 문자가 존재하는지 확인하여 위치(index)를 알려줌, 없으면 -1를 반환|String s = "Sunny";<br>int idx1 = s.indexOf('y');<br>int idx2 = s.indexOf('z');|idx1 = 4<br>idx2 = -1|


{% highlight java %}

{% endhighlight %}

![image](/img/2019-10-14/CentOS-Install-CLI-040-putty4.png)
